/**
 * Copyright (C) 2020 Stealth Software Technologies Commercial, Inc.
 */

#include "evwrapper.h"

/* C++ Headers */
#include <mutex>
#include <stdexcept>
#include <string>
#include <vector>

/* 3rd Party Headers */
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/ssl.h>
#include <openssl/x509.h>
#include <sst/checked.h>

/* SAFRN Headers */
#include <Util/Utils.h>

/* logging config */
#include <ff/logging.h>

namespace safrn {
void evw_deleter::operator()(evutil_addrinfo * ptr) {
  evutil_freeaddrinfo(ptr);
}

void evw_deleter::operator()(bufferevent * ptr) {
  bufferevent_free(ptr);
}

void evw_deleter::operator()(evbuffer * ptr) {
  evbuffer_free(ptr);
}

void evw_deleter::operator()(evconnlistener * ptr) {
  evconnlistener_free(ptr);
}

void evw_deleter::operator()(evutil_socket_t * const ptr) const
    noexcept {
  log_assert(ptr != nullptr);
  int const s = evutil_closesocket(*ptr);
  if (s != 0) {
    try {
      log_warn("evutil_closesocket() failed and returned %d", s);
    } catch (...) {
    }
  }
}

event_base * evtbase;
evdns_base * dnsbase;

void evw_startup() {
  evtbase = event_base_new();
  dnsbase = evdns_base_new(evtbase, 1);
}

void evw_teardown() {
  evdns_base_free(dnsbase, 0);
  event_base_free(evtbase);
}

std::string getOpenSSLErrorString() {
  std::string s(1024, '\0');
  ERR_error_string_n(ERR_get_error(), &s[0], s.size());
  s.resize(s.find('\0'));
  return s;
}

SSL_CTX * Global_SSL_Context = nullptr;

void initializeOpenSSL(
    std::string const & ca_file,
    std::string const & ca_path,
    std::string const & crt_file,
    std::string const & key_file) {
  log_assert(!ca_file.empty() || !ca_path.empty());
  log_assert(!crt_file.empty());
  log_assert(!key_file.empty());

  static std::once_flag flag_1;
  static std::once_flag flag_2;

  std::call_once(flag_1, [&]() noexcept {
    SSL_library_init();
    SSL_load_error_strings();
    ERR_load_crypto_strings();
    OpenSSL_add_all_algorithms();
    OpenSSL_add_all_ciphers();
    OpenSSL_add_all_digests();
  });

  std::call_once(flag_2, [&]() {
    SSL_METHOD const * const method = SSLv23_method();
    if (method == nullptr) {
      throw std::runtime_error(
          "SSLv23_method() failed: " + getOpenSSLErrorString());
    }

    customUniquePtr_t<SSL_CTX> ctx(
        SSL_CTX_new(method),
        [](SSL_CTX * const p) { SSL_CTX_free(p); });
    if (ctx.get() == nullptr) {
      throw std::runtime_error(
          "SSL_CTX_new(SSLv23_method()) failed: " +
          getOpenSSLErrorString());
    }

    {
      auto const s = SSL_CTX_load_verify_locations(
          ctx.get(),
          ca_file.empty() ? nullptr : ca_file.c_str(),
          ca_path.empty() ? nullptr : ca_path.c_str());
      if (s != 1) {
        throw std::runtime_error(
            "SSL_CTX_load_verify_locations(ctx.get(), ca_file = " +
            (ca_file.empty() ? std::string("nullptr") :
                               quoteForError(ca_file)) +
            ", ca_path = " +
            (ca_path.empty() ? std::string("nullptr") :
                               quoteForError(ca_path)) +
            ") failed: " + getOpenSSLErrorString());
      }
    }

    {
      auto const s = SSL_CTX_use_certificate_chain_file(
          ctx.get(), crt_file.c_str());
      if (s != 1) {
        throw std::runtime_error(
            "SSL_CTX_use_certificate_chain_file(ctx.get(), crt_file "
            "= " +
            quoteForError(crt_file) +
            ") failed: " + getOpenSSLErrorString());
      }
    }

    {
      auto const s = SSL_CTX_use_PrivateKey_file(
          ctx.get(), key_file.c_str(), SSL_FILETYPE_PEM);
      if (s != 1) {
        throw std::runtime_error(
            "SSL_CTX_use_PrivateKey_file(ctx.get(), key_file = " +
            quoteForError(key_file) +
            ", SSL_FILETYPE_PEM) failed: " + getOpenSSLErrorString());
      }
    }

    {
      auto const s = SSL_CTX_check_private_key(ctx.get());
      if (s != 1) {
        throw std::runtime_error(
            "SSL_CTX_check_private_key(ctx.get()) failed: " +
            getOpenSSLErrorString());
      }
    }

    SSL_CTX_set_verify(
        ctx.get(),
        SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
        nullptr);

    SSL_CTX_set_options(
        ctx.get(), SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1);

    {
      // This cipher list was generated by the default
      // <https://ssl-config.mozilla.org> page on 2020-06-03.
      auto const cipher_list =
          "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:"
          "ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:"
          "ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:"
          "DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384";
      auto const s = SSL_CTX_set_cipher_list(ctx.get(), cipher_list);
      if (s != 1) {
        throw std::runtime_error(
            "SSL_CTX_set_cipher_list(ctx.get(), cipher_list = " +
            quoteForError(cipher_list) +
            ") failed: " + getOpenSSLErrorString());
      }
    }

    Global_SSL_Context = ctx.release();
  });
}

std::string getErrorString(bufferevent & bev) {
  // Call EVUTIL_SOCKET_ERROR() as soon as possible to avoid any
  // interposing code possibly destroying it, as some versions of
  // libevent might just use #define EVUTIL_SOCKET_ERROR() (errno).
  auto const socket_error = EVUTIL_SOCKET_ERROR();

  auto const openssl_error = bufferevent_get_openssl_error(&bev);

  std::string error_string;

  if (socket_error != 0) {
    if (error_string.size() != 0) {
      error_string += ", ";
    }
    error_string += "Socket error: ";
    error_string += evutil_socket_error_to_string(socket_error);
  }

  if (openssl_error != 0) {
    if (error_string.size() != 0) {
      error_string += ", ";
    }
    error_string += "OpenSSL error: ";
    error_string += getOpenSSLErrorString();
  }

  return error_string;
}

static std::vector<unsigned char> getCertificateFingerprint(
    X509 const & certificate, EVP_MD const & algorithm) {
  int const n = EVP_MD_size(&algorithm);
  if (n <= 0) {
    throw std::runtime_error("EVP_MD_size() failed");
  }

  std::vector<unsigned char> fingerprint(
      sst::checked_cast<std::vector<unsigned char>::size_type>(n));

  auto const s = X509_digest(
      &certificate, &algorithm, fingerprint.data(), nullptr);
  if (s != 1) {
    throw std::runtime_error(
        "X509_digest() failed: " + getOpenSSLErrorString());
  }

  return fingerprint;
}

EVP_MD const & getHashAlgorithmByName(std::string const & name) {
  EVP_MD const * const p = EVP_get_digestbyname(name.c_str());
  if (p == nullptr) {
    throw std::runtime_error(
        "EVP_get_digestbyname(" + quoteForError(name) +
        ") failed: " + getOpenSSLErrorString());
  }
  return *p;
}

std::vector<unsigned char>
getMyCertificateFingerprint(EVP_MD const & algorithm) {
  return getCertificateFingerprint(
      *SSL_CTX_get0_certificate(Global_SSL_Context), algorithm);
}

std::vector<unsigned char> getPeerCertificateFingerprint(
    bufferevent & bev, EVP_MD const & algorithm) {
  // We always use SSL connections by design, so there should always be
  // an SSL session in bev.
  SSL * const ssl = bufferevent_openssl_get_ssl(&bev);
  log_assert(ssl != nullptr);

  // We always authenticate peers by design, so there should always be a
  // peer certificate in the SSL session.
  customUniquePtr_t<X509> certificate(
      SSL_get_peer_certificate(ssl),
      [](X509 * const p) { X509_free(p); });
  log_assert(certificate.get() != nullptr);

  return getCertificateFingerprint(*certificate, algorithm);
}

} // namespace safrn
