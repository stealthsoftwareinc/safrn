/**
 * Copyright (C) 2020 Stealth Software Technologies Commercial, Inc.
 */

#ifndef SAFRN_SESSION_CONFIG_H_
#define SAFRN_SESSION_CONFIG_H_

/* c/c++ standard includes */
#include <cstdint>
#include <map>
#include <set>
#include <string>
#include <unordered_map>
#include <vector>

/* third-party library includes */
#include <nlohmann/json.hpp>
#include <openssl/evp.h>

/* project-specific includes */
#include <JSON/Columns/ColumnBase.h>
#include <JSON/Query/JoinType.h>
#include <JSON/Query/QueryTypes.h>
#include <JSON/Query/SafrnFunction.h>
#include <PeerSet.h>
#include <Util/Utils.h>

/**
 * The StudyConfig object in code will read both the Study Configuration
 * file and the Peer Configuration File, joining the peer section of the
 * Study file with the connection information in the Peer file.
 */

namespace safrn {

struct Vertical {
  /**
     * A vertical's ID is a unique ID generated by the dashboard which
     * created the study config.
     */
  VerticalIndex_t verticalIndex;

  /**
     * The list of columns in this vertical.
     */
  std::vector<std::unique_ptr<ColumnBase>> columns;
};

struct Peer {
  /**
     * The organization ID of the peer.
     *
     * correlated between peer and study config files.
     */
  dbuid_t organizationId;

  /**
   * The (optional) name of the organization.
   */
  std::string organizationName = "unknown";

  /**
     * Either the domain name or the IP address of this peer.
     *
     * This is read from the peer config file.
     */
  std::string domainOrIp;

  /**
     * TCP port number for ``connect``ing to this peer.
     *
     * comes from peer config file.
     */
  uint16_t port;

  /**
   * Fingerprint of the TLS certificate of this peer.
   */
  EVP_MD const * certificateFingerprintAlgorithm;
  std::vector<unsigned char> certificateFingerprint;

  role_t role = 0x00;

  bool isAnalyst() const;

  bool isDataowner() const;

  bool isDealer() const;

  bool isRecipient() const;

  bool hasRole(role_t r) const;

  /**
     * The Analyst role.
     *
     * From the study config.
     */
  struct {
    // DEPRECATED. The following field is not yet supported.
    int allowedQueryCount = 0;
  } analyst;

  /**
     * The Dataowner role.
     *
     * From the study config.
     */
  struct {
    VerticalIndex_t verticalIdx;
  } dataowner;
};

struct StudyConfig {
  /**
     * Each study will be given a unique ID by the dashboard which
     * configured it.
     */
  dbuid_t studyId;

  /**
   * The lexicon is simply a list of the verticals allowed by the lexicon.
     */
  std::vector<Vertical> lexicon;

  /** The maximum number of observations (rows) that every party
   *  must observe (i.e. there can be no dataowners who provide
   *  more than this many rows of data.)
   */
  size_t maxListSize;

  /** Specify the permissible functions to be run as part of this study.
   *  WARNING: This field not fully supported yet. Indeed, it only
   *  supports checking whether Moment queries allow returning of Count.
   */
  std::vector<std::unique_ptr<SafrnFunction>> allowedQueries;

  /**
     * Map of organization ID to Peer objects for all peers in this study.
     * TODO: The orgID info is redundant (stored both as the key to the
     * map below, as well as stored within each Peer object).
     * Consider removing the redundancy, either by revmoving the
     * organizationId field from Peer, or by making `peers` below
     * be a vector instead of a map.
     */
  std::map<dbuid_t, Peer> peers;

  Vertical const * getVertical(dbuid_t orgId) const;
  size_t getVerticalIdx(dbuid_t orgId) const;
};

void readStudyFromFile(
    std::string const & sessFile,
    std::string const & peerFile,
    StudyConfig & cfg);
StudyConfig readStudyFromJson(json const & study, json const & peers);
// The following parses just the primary part of the study config, i.e.
// the `peers` field will be incomplete.
StudyConfig readStudyFromJson(json const & study);

// Rules to enforce that define a 'valid' query for a given SAFRN Study.
// TODO: Consider adding an API that sets fields according to a Study config
// (or from some other config file).
struct QueryRules {
  bool allow_prefilters_ = true;
  bool allow_postfilters_ = false;
  bool identity_join_on_only_ = true;

  // If empty, assume all JOIN types are valid.
  std::set<JoinType::Enum_t> allowed_join_types_;
  VerticalIndex_t min_compute_verticals_ = 1;
  VerticalIndex_t max_compute_verticals_ = 2;
  ColumnIndex_t max_join_on_cols_ = 0; // '0' denotes no limit.
};

// Return codes for whether a query is valid.
enum class QueryValidCode {
  VALID,
  INVALID_PREFILTER,
  INVALID_POSTFILTER,
  INVALID_NUMBER_OF_SELECT_VERTICALS,
  INVALID_NUMBER_OF_COMPUTE_VERTICALS,
  INVALID_JOIN_TYPE,
  INVALID_JOIN_STATEMENT,
  INVALID_JOIN_ON,
};

} // namespace safrn

#endif
